<?php

/*************************************************************************
* This file is part of the MathHub.info System  (http://mathhub.info).   *
* It is hosted at https://github.com/KWARC/MathHub                       *
* Copyright (c) 2015 by the KWARC group (http://kwarc.info)              *
* Licensed under GPL3, see http://www.gnu.org/licenses/gpl.html          *
**************************************************************************/

require_once 'oaff.base.php';

/**
 * Declares the menu links added by this file 
 * (is aggregated in oaff_menu function)
 * @param $items the menu items so far
 * @return the modified items array with the new entries added
 */
function oaff_aspects_menu(& $items) {
  $items['node/%node/svg'] = array(
    'title' => 'SVG',
    'page callback' => 'oaff_aspects_node_svg',
    'page arguments' => array(1),
    'access callback' => 'oaff_aspects_access_node_by_comp',
    'access arguments' => array(1, array("svg")),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['node/%node/omdoc'] = array(
    'title' => 'OMDoc',
    'page callback' => 'oaff_aspects_node_omdoc',
    'page arguments' => array(1),
    'access callback' => 'oaff_aspects_access_node_by_comp',
    'access arguments' => array(1, array("stex-omdoc")),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['node/%node/source'] = array(
    'title' => 'Source',
    'page callback' => 'oaff_aspects_node_source',
    'page arguments' => array(1),
    'access callback' => 'oaff_aspects_access_node_by_comp',
    'access arguments' => array(1, array("latexml", "mmt-omdoc")),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
	return $items;
}


/**
* Returns true if access is allowed to a specific aspect for the current node
* Checks if the node uses one of the compilers the aspect covers
* @param $node The node to check access for
* @param $aspect_comps : Array[String] ids of the compilers this aspect is active for
*/
function oaff_aspects_access_node_by_comp($node, $aspect_comps) {
  if ($node->type == "oaff_doc" || $node->type == "oaff_virtdoc") {
    $filter = $node->field_external['und']['0']['filter'];
    $format = variable_get('oaff_config')['config']['formats'][$filter];
    $compilers = array_merge($format['importers'], $format['exporters']);
    return array_intersect($aspect_comps, $compilers);
  } else {
    if ($node->type == "oaff_helpdoc" && in_array("svg", $aspect_comps)) {
      $path = $node->field_external['und'][0]['path'];
      $segs = explode("/", $path);
      if ($segs[0] != 'meta' && $segs[1] != 'meta-inf') {
        return true;
      }
    }
    return false;
  }
}

/**
 * Helper function for svg aspect (oaff_aspects_node_svg)
 * @param $pathinfo path information of the source document (as generated by oaff_base_get_path_info)   
 * @return raw svg content
 */
function oaff_aspects_svg_html($pathinfo) {
  $relpath = $pathinfo['rel_path'];
  $args = explode(".", $relpath);
  if (count($args) == 1) {
    $svgname = oaff_base_join_path(array($relpath, ".svg"));
  } else {
    array_pop($args);
    $svgname = implode(".",$args) . ".svg";
  }
  $svg_content = planetary_repo_load_file(oaff_base_join_path(array($pathinfo['group'], $pathinfo['archive'], "export/svg/narration", $svgname)));
  return $svg_content; 
}

/**
* Function that returns formated SVG for the given node that can be panned and zoomed
* @param $node The node to generate SVG for
* @return the generated html5 fragment 
*/
function oaff_aspects_node_svg($node) {
  $nid = $node->nid;
  $location = $node->field_external['und']['0']['path'];
  $alias = oaff_base_get_path_info($location)['alias'];
  $format = oaff_get_node_filter_format($node);
  if ($node->type == "oaff_helpdoc") {
    $segs = explode("/", $location);
    $format = "stex"; //TODO fix this with svg filter instead of format/aspect in oaff_base_initialize
    $location = oaff_base_join_path(array($segs[0], $segs[1], "source"));
  }
  oaff_set_breadcrumb($nid, array($nid));
  // script for zoom and pan
  $oaff_path = drupal_get_path('module', 'oaff');
  $svg_script = '/' . $oaff_path . '/scripts/svg-pan-zoom.js';
  drupal_add_js($svg_script, 'file');
  
  // modules
  $inst_id = oaff_base_initialize($location, $format, "svg");

  // activate zoom and pan of SVG
  $activate_pan_zoom = 
    '// Don\'t use window.onLoad like this in production, because it can only listen to one function.
      window.onload = function() {
        // Expose to window namespase for testing purposes
        window.zoomTiger = svgPanZoom(\'#node-svg\', {
          zoomEnabled: true,
          controlIconsEnabled: true,
          fit: true,
          center: true,
          viewportSelector: document.getElementById(\'node-svg\').querySelector(\'#wrapper\')
        });
      };';

  $pathinfo = oaff_base_get_path_info($location);
  $out = oaff_aspects_svg_html($pathinfo);
  $content = 
'   <div id="' . $inst_id . '" style="border:3px solid #5DBCD2; border-radius: 5px;">' . 
        oaff_aspects_svg_clean($out) .
'   </div>
    <script>
      ' . $activate_pan_zoom . '    
    </script>';  
  if (isset($_GET['view'])) {
    oaff_aspects_generate_blank_page(($node->title) . ' | SVG' , $content);
  } else {
    $out = "<a class=\"btn btn-default btn-sm\" target=\"_blank\" href=\"?view=full\" role=\"button\">Full screen</a>" . $content;
   ; 
    return $out;
  }
}


/**
* Returns SVG as a string where header is replaced to allow panning and zoom functionality
* @param $svg SVG as a string
* @return the 'cleaned' SVG element as a string 
*/
function oaff_aspects_svg_clean($svg) {
  $out = substr($svg, strpos($svg, '<svg'));
  $out = substr($out, strpos($out, '>')+1);
  $out = substr($out, 0, strpos($out, '</svg>'));
  $out = 
      "\n<svg id=\"node-svg\" xmlns=\"http://www.w3.org/2000/svg\" height=\"720px\" width=\"100%\">" .
      "\n<g id=\"wrapper\">" . $out . "\n</g></svg>";
  return $out;
}


/**
* Generates OMDoc of the node
* @param $node The node to get OMDoc for
* @return the omdoc as a string within a html5 `pre` element
*/
function oaff_aspects_node_omdoc($node) {
  $nid = $node->nid;
  $location = $node->field_external['und']['0']['path'];
  oaff_set_breadcrumb($nid, array($nid));
  // change path extension of file from .* to .omdoc
  $pathinfo = oaff_base_get_path_info($location);
  $omdoc_location = oaff_base_join_path(array($pathinfo['group'], $pathinfo['archive'], 'latexml', $pathinfo['rel_parent'], $pathinfo['title'] . '.omdoc'));
  $omdoc = ""; //default
  if (planetary_repo_stat_file($omdoc_location)) { //omdoc exists
    $omdoc = planetary_repo_load_file($omdoc_location);
  }
  return "<pre>\n" . check_plain($omdoc) . "\n</pre>";
}


/**
 * function to mark errors, annotates source string with error information
 * @param $source the source string
 * @param $nid the node id
 * @param $status the error array 
 * @return the processed string (with errors marked)
 */
function oaff_aspects_mark_source_errors($source, $nid, $status) {
  $error_catalog = array(0 => "Info", 1 => "Warning", 2 => "Error", 3 => "Fatal");

  // separate errors by compilers
  $errors_compiler = array();
  foreach ($status as $key => $value) {
    if (!isset($errors_compiler[$value->compiler]))
      $errors_compiler[$value->compiler] = array(); 
    $errors_compiler[$value->compiler][] = $value; 
  }

  // collect unique references
  $srcrefs = array();
  foreach ($status as $key => $error) {
    if ($error->srcref != "") {
      $pcs = explode("-", $error->srcref);
      $srcrefs[$pcs[0]] = 0; 
      
      //
      $to = explode(".", $pcs[1]);
      $to_line = $to[0];
      $to_column = (string) (1 + (int) $to[1]); 
      $srcrefs[(implode(".", array($to_line, $to_column)))] = 0;
    }
  }

  $srcrefs = array_keys($srcrefs);
  sort($srcrefs);

  // separating to the array where keys are line numbers
  $refs = array();
  foreach ($srcrefs as $srcref) {
    $slices = explode(".", $srcref);
    $ref = (int) $slices[0];
    if (!isset($refs[$ref]))
      $refs[$ref] = array();
    $refs[$ref][] = (int) $slices[1];
  }

  $lines = explode("\n", $source);
  $line_offsets = array(0);
  $i = 0;
  $new_lines = array();
  while ($i < count($lines)) {
    $line_offsets[] = $line_offsets[$i] + strlen($lines[$i]);
    $i += 1;
  }

  $source = oaff_aspects_tokenize_source($source, $refs);

  $out = "";

  $notification_counter = 0;
  $inst_id = oaff_base_initialize();
  foreach ($errors_compiler as $compiler => $errors) {
    $register = "";
    $unregister = "";
    $selector = "";
    $out .= '
    <label class="btn btn-primary btn-sm">
      <input id="'. $compiler . '" type="checkbox"> '. $compiler . ' 
    </label>';
    foreach ($errors as $msg) {
      // errors with references
      if ($msg->srcref) {
        $parts = explode("-",$msg->srcref);
        $from_parts = explode(".",$parts[0]);
        $to_parts = explode(".", $parts[1]);

        $from_line = $from_parts[0]; 
        $from_col = $from_parts[1];
        $from = $line_offsets[$from_line - 1] + $from_col; //-1 since arrays start at 0, line numbers at 1
        $to_line = $to_parts[0];
        $to_col = $to_parts[1];
        $to = $line_offsets[$to_line - 1] + $to_col; //-1 since arrays start at 0, line numbers at 1
        
        
        // select several spans
        $ids = oaff_aspects_get_middle_elements($srcrefs, $parts[0], $parts[1]);
        $selector ="";
        $last_key = count($ids) - 1;
        foreach ($ids as $key => $id) {
          $selector .= "#ref_" . str_replace(".", "_", $id);
          if ($key != $last_key)
            $selector .= ", ";
        }
        $edit_query = '?start=' . $from . '&end=' . $to;
      } else {
        // errors w/o references assign to whole source code
        $selector = "#ref_general";
        $edit_query = "";
      }
      $register .= '
        n'. $notification_counter . ' = ' . $inst_id .'.Sidebar.registerNotification(jQuery("' . $selector . '"), 
            { 
              "class": "' . strtolower($error_catalog[$msg->type]) .'",
              "text": "' .  str_replace('"', "'", $msg->short_msg) . '", 
              "click": function() {
                window.open("/node/'.$nid.'/edit' . $edit_query . '");
              },
              "trace":true,
          });';
      $unregister .= '
          '. $inst_id .'.Sidebar.removeNotification(n' . $notification_counter . ');'; 
      $notification_counter++;
    }

    // js to constantly check checkboxes status
    $sidebar = "jQuery(function(){
       jQuery('#{$compiler}').change(function(){
          if(jQuery(this).is(':checked')) {
              $register
          } else {
              $unregister
          }
       });
    });";

    drupal_add_js($sidebar, array('type' => 'inline', 'weight' => 100));
  }

  // if there are errors add them to outpu
  if ($out != "") {
    $out = '<div>
    <label> Compilers </label> 
    <div class="btn-group" data-toggle="buttons">'.
      $out .'
    </div>
</div><br/>';
  }

  $out .= "<div id=\"$inst_id\"><pre id=\"ref_general\">\n" . $source . "\n</pre></div>";
  return $out;
}

/**
* separates $source by spans with id="ref_{line number}_{column number}"
* @param $source string to tokenize
* @param $srcref array where
*        key is line number
*        value is array of column numbers
* @return tokenized string
*/ 
function oaff_aspects_tokenize_source($source, $srcref) {
  $lines = explode("\n", $source);
  $line_offsets = array(0);
  $i = 0;
  $close_tag = false;
  foreach ($srcref as $line_num => $char_nums) {
    $line = $lines[$line_num - 1];
    $new_line = "";
    if ($char_nums[0] != 1)
      $new_line .= substr($line, 0, $char_nums[0] - 1);
    if ($close_tag) {
      $new_line .= "</span>";
      $close_tag = false;
    }
    for ($j = 0; $j < count($char_nums) - 1; $j++) {
      $new_line .= "<span id=\"ref_{$line_num}_{$char_nums[$j]}\">";
      $new_line .= substr($line, $char_nums[$j] - 1, $char_nums[$j+1] - $char_nums[$j]);
      $new_line .= "</span>";
    }
    $new_line .= "<span id=\"ref_{$line_num}_" . $char_nums[count($char_nums)-1] . "\">";
    $new_line .= substr($line, $char_nums[count($char_nums)-1]-1);
    $close_tag = true;
    $lines[$line_num - 1] = $new_line;
  }
  $source = implode("\n", $lines);
  if ($close_tag)
    $source .= "</span>"; 
  return $source;
}


/**
* @param $array array sorted in increasing order by value
* @param $from value from which begin collecting values
* @param $to value from/after which stop collecting values
* @return array of values between $from and $to, including $from
*/
function oaff_aspects_get_middle_elements($array, $from, $to) {
  $out = array();
  $in_middle = false;
  foreach ($array as $key => $value) {
    if ($value >= $to)
      break;
    if ($value == $from) {
      $in_middle = true;
    }
    if ($in_middle)
      $out[] = $value;
  }
  return $out;
}

/**
* Returns source code of the document of the node
* @param $node The node to get source code for
*/
function oaff_aspects_node_source($node) {
  $nid = $node->nid;
  $location = $node->field_external['und']['0']['path'];
  oaff_set_breadcrumb($nid, array($nid));
  $source = planetary_repo_load_file($location);
  $status = oaff_get_errors($nid);
  $output = oaff_aspects_mark_source_errors(check_plain($source), $nid, $status);
  return $output; 
}

/**
* @return Javascript for the current node as a string. Should
* be included in the head of the page.
*/
function oaff_aspects_get_js_as_string() {
  $scripts = drupal_add_js();
  planetary_libs_js_alter($scripts);
  $base_url = $GLOBALS['base_url'];
  $out = '';
  foreach ($scripts as $key => $script) {
    // ignore drupal related scripts
    if ($key === 'settings' 
      || $key === "misc/drupal.js"
      || $key === "sites/all/modules/devel/devel_krumo_path.js")
      continue;
    switch ($script['type']) {
      case 'external':
        $path = $script['data'];
        $out .= "<script src=\"$path\"></script>\n";
        break;

      case 'file':
        $path = $script['data'];
        if ($path[0] != '/')
          $path = '/' . $path;
        $out .= "<script src=\"{$base_url}{$path}\"></script>\n";
        // add bootstrap manually after jQuery. TODO
        if ($key === 'misc/jquery.js')
          $out .= "<script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js\"></script>\n";
        break;

      case 'inline':
        $data = $script['data'];
        $out .= "<script>$data</script>\n";
        break;
      
      default:
        break;
    }
  }
  return $out;
}

/**
* @return CSS for the current node as  a string. Should
* be included in the head of the page.
*/
function oaff_aspects_get_css_as_string() {
  $csss = drupal_add_css();
  planetary_libs_css_alter($csss);
  $base_url = $GLOBALS['base_url'];
  // add bootstrap manually after jQuery. TODO
  $out = '<link type="text/css" rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" media="all" />';
  foreach ($csss as $key => $css) {
    $path = $css['data'];
    // ignore drupal internal css
    if (startsWith($path, 'modules'))
      continue;
    if ($path[0] != '/')
      $path = '/' . $path;
    $out .= "<link type=\"text/css\" rel=\"stylesheet\" href=\"{$base_url}{$path}\" media=\"all\" />\n";
  }
  return $out;
}

/** 
* Generates blank page (page w/o Drupal menu)
* @param $title The title of the new page
* @param $body The content of the body of the page
*/
function oaff_aspects_generate_blank_page($title, $body) {
  $out = 
'<!DOCTYPE html>
<html>
  <head>
    <title>' . $title . '</title>' . 
    oaff_aspects_get_css_as_string() .
    oaff_aspects_get_js_as_string() . '
  </head>
  <body>
  '. $body . '
  </body>
</html>';
  print($out);
}